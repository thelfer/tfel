@Parser    Implicit;
@Behaviour MonoCristal_DD_CFC;
@Algorithm NewtonRaphson_NumericalJacobian;
@Author    Jean-Michel Proix;
@Date      11/06/2013;
@Description{
  "On implante ici la loi MONO_DD_CFC décrite dans la documentation du"
  "code Aster R5.03.11."
 
  "Elle est construite à partir de calculs de dynamique des "
  "dislocations. Elle s'applique aux matériaux à structure cristalline "
  "Cubique à Faces Centrées (CFC) tels que les aciers austénitiques. A "
  "priori le modèle DD_CFC n'est pas compatible avec un changement de "
  "trajet de chargement, en particulier les paramètres ne sont pas "
  "adaptés à une sollicitation cyclique (lorsqu'une dislocation "
  "\og~revient sur ses pas~\fg sa cinétique est différente du fait "
  "d'une interaction différente avec les obstacles)."
}

@ModellingHypothesis Tridimensional;
@OrthotropicBehaviour;
@RequireStiffnessTensor;

@Theta 1.0;

@Epsilon 1.e-9 ;
@IterMax 100 ;

@MaterialProperty real tauf;
@MaterialProperty real y;
@MaterialProperty real pn;
@MaterialProperty real gamma0;
@MaterialProperty real a;
@MaterialProperty real b;
@MaterialProperty real rhoref;
@MaterialProperty real alpha;
@MaterialProperty real beta;
@MaterialProperty real Mu;

@StateVariable strain  omega[12];

@AuxiliaryStateVariable real g[12];
@AuxiliaryStateVariable real p[12];
@AuxiliaryStateVariable real tau[12];
@LocalVariable real    Dp[12];
@LocalVariable real    Dg[12];

@TangentOperator{
  if((smt==ELASTIC)||(smt==SECANTOPERATOR)){
    Dt = D;
  } else if (smt==CONSISTANTTANGENTOPERATOR){
    Stensor4 Je;
    getPartialJacobianInvert(Je);
    Dt = D*Je;
  } else {
    return false;
  }
}

@Includes{
#include"TFEL/Material/MetallicCFCSlidingSystems.hxx"
}
@Import"MonoCristal_DD_CFC_InteractionMatrix.mfront";

@Members{
  // Mono cristal gliding system
  typedef MetallicCFCSlidingSystems<real> SlidingSystems;
  // number of sliding systems
  static const unsigned short Nss = SlidingSystems::Nss;
}

@ComputeStress{
  sig = D*eel;
}

@Integrator{
  const SlidingSystems& ss = SlidingSystems::getSlidingSystems();
  StrainStensor Depsp(real(0));
  real ppomega[Nss];
  real sgn=0.0;
  real C=1.0;
  real sum=0.0;
  for(unsigned short k=0;k!=Nss;++k){
    ppomega[k]=max(0.,omega[k]+theta*domega[k]);
    sum+=ppomega[k];
  }
  if (alpha>0.){
    C=0.2+0.8*log(alpha*sqrt(sum))/log(alpha*beta*sqrt(rhoref));
  }
  for(unsigned short i=0;i!=Nss;++i){
    real taufor2=0.0;
    for(unsigned short j=0;j!=Nss;++j){
      taufor2+=mh(i,j)*ppomega[j];
    }
    real taufor=Mu*C*sqrt(taufor2);
    tau[i] = ss.mus[i] | sig ;
    real terme=abs(tau[i])/(tauf+taufor);
    real h=0.;
    if (terme>1.){
      Dp[i]  = dt*gamma0*pow(terme,pn)-dt*gamma0;
      sgn=tau[i]/abs(tau[i]);
      Dg[i]  = sgn*Dp[i];
      Depsp+=Dg[i]*ss.mus[i] ;
      // forest
      real ha=0.0;
      real hb=0.0;
      real hc=0.0;
      for(unsigned short j=0;j!=Nss;++j){
	if (i/3!=j/3){
	  ha+=sqrt(mh(i,j))*ppomega[j];
	} else {
	  hc+=sqrt(mh(i,j)*ppomega[j]);
	}
	hb+=sqrt(mh(i,j)*ppomega[j]);
      }
      h=a*ha/hb+b*C*hc-y/beta*ppomega[i];
    } else {
      Dp[i]=0.;
      Dg[i]=0.;
    }
    fomega[i] = domega[i]-Dp[i]*h;
  }
  feel += Depsp-deto;
} 

@UpdateAuxiliaryStateVars{
  for(unsigned short k=0;k!=Nss;++k){
    p[k]+=Dp[k];
    g[k]+=Dg[k];
  }
}
