/*!
 * \file   mfront/src/CMaterialPropertyInterfaceBase.cxx
 * \brief
 * \author Thomas Helfer
 * \date   06 mai 2008
 * \copyright Copyright (C) 2006-2025 CEA/DEN, EDF R&D. All rights
 * reserved.
 * This project is publicly released under either the GNU GPL Licence with
 * linking exception or the CECILL-A licence. A copy of thoses licences are
 * delivered with the sources of TFEL. CEA or EDF may also distribute this
 * project under specific licensing conditions.
 */

#include <sstream>
#include <stdexcept>
#include "TFEL/Raise.hxx"
#include "MFront/DSLUtilities.hxx"
#include "MFront/MFrontHeader.hxx"
#include "MFront/FileDescription.hxx"
#include "MFront/MaterialPropertyDescription.hxx"
#include "MFront/CMaterialPropertyInterfaceBase.hxx"

namespace mfront {

  static std::string transformHeaderName(const std::string& h) {
    auto replace = [](std::string& s, const std::string::value_type a,
                      const std::string::value_type b) {
      std::string::size_type p = 0;
      while ((p = s.find(a)) != std::string::npos) {
        s[p] = b;
      }
    };
    auto header = makeUpperCase(h);
    replace(header, '.', '_');
    replace(header, '-', '_');
    replace(header, '/', '_');
    return header;
  }  // end of transformHeaderName

  CMaterialPropertyInterfaceBase::CMaterialPropertyInterfaceBase() = default;

  void CMaterialPropertyInterfaceBase::writeHeaderPreprocessorDirectives(
      std::ostream& os, const MaterialPropertyDescription&) const {
    writeExportDirectives(os);
  }  // end of writeSrcPreprocessorDirectives

  void CMaterialPropertyInterfaceBase::writeSrcPreprocessorDirectives(
      std::ostream&, const MaterialPropertyDescription&) const {
  }  // end of writeSrcPreprocessorDirectives

  void CMaterialPropertyInterfaceBase::writeOutputFiles(
      const MaterialPropertyDescription& mpd, const FileDescription& fd) const {
    this->writeHeaderFile(mpd, fd);
    this->writeSrcFile(mpd, fd);
  }  // end of writeOutputFiles

  std::string CMaterialPropertyInterfaceBase::getCallingConvention() const {
    return "";
  }

  void CMaterialPropertyInterfaceBase::writeHeaderFile(
      const MaterialPropertyDescription& mpd, const FileDescription& fd) const {
    // the fortran interface does not need any header...
    const auto header = this->getHeaderFileName(mpd.material, mpd.className);
    if (header.empty()) {
      return;
    }
    const auto fn = "include/" + header + ".hxx";
    std::ofstream os(fn);
    tfel::raise_if(!os,
                   "CMaterialPropertyInterfaceBase::writeOutputFiles : "
                   "unable to open '" +
                       fn + "' for writing output file.");
    os.exceptions(std::ios::badbit | std::ios::failbit);
    const auto headerGard = transformHeaderName(header) + "_HH";
    os << "/*!\n"
       << "* \\file   " << fn << "\n"
       << "* \\brief  "
       << "this file declares the " << mpd.className << " MaterialLaw.\n"
       << "*         File generated by " << MFrontHeader::getVersionName()
       << " "
       << "version " << MFrontHeader::getVersionNumber() << "\n";
    if (!fd.authorName.empty()) {
      os << "* \\author " << fd.authorName << "\n";
    }
    if (!fd.date.empty()) {
      os << "* \\date   " << fd.date << "\n";
    }
    if (!fd.description.empty()) {
      os << fd.description << "\n";
    }
    os << " */\n\n"
       << "#ifndef " << headerGard << "\n"
       << "#define " << headerGard << "\n\n";
    writeExportDirectives(os);
    this->writeHeaderPreprocessorDirectives(os, mpd);
    this->writeBeginHeaderNamespace(os);
    os << "MFRONT_SHAREDOBJ double " << this->getCallingConvention() << '\n'
       << this->getFunctionName(mpd);
    os << "(";
    this->writeArgumentsList(os, mpd);
    os << ");\n\n";
    if (((hasBounds(mpd.inputs)) || (hasPhysicalBounds(mpd.inputs))) ||
        (this->requiresCheckBoundsFunction())) {
      os << "MFRONT_SHAREDOBJ int " << this->getCallingConvention() << '\n'
         << this->getCheckBoundsFunctionName(mpd);
      os << "(";
      this->writeArgumentsList(os, mpd);
      os << ");\n\n";
    }
    this->writeEndHeaderNamespace(os);
    os << "#endif /* " << headerGard << " */\n";
    os.close();
  }  // end of writeHeaderFile()

  void CMaterialPropertyInterfaceBase::writeInterfaceSpecificVariables(
      std::ostream& os, const MaterialPropertyDescription& mpd) const {
    if ((!useQuantities(mpd)) && (!mpd.inputs.empty())) {
      return;
    }
    for (const auto& a : mpd.inputs) {
      os << "const auto " << a.name << " = "  //
         << a.type << "(mfront_" << a.name << ");\n";
    }
  }  // end of writeInterfaceSpecificVariables

  void CMaterialPropertyInterfaceBase::writeArgumentsList(
      std::ostream& os, const MaterialPropertyDescription& mpd) const {
    const auto use_qt = useQuantities(mpd);
    if (!mpd.inputs.empty()) {
      for (auto p = mpd.inputs.begin(); p != mpd.inputs.end();) {
        const auto n = (use_qt ? "mfront_" : "") + p->name;
        os << "const double " << n;
        if ((++p) != mpd.inputs.end()) {
          os << ",";
        }
      }
    } else {
      os << "void";
    }
  }  // end of writeArgumentsList

  VariableDescriptionContainer::size_type
  CMaterialPropertyInterfaceBase::getVariableNumber(
      const MaterialPropertyDescription& mpd, const std::string& n) {
    VariableDescriptionContainer::size_type nbr = 1u;
    for (const auto& i : mpd.inputs) {
      if (i.name == n) {
        return nbr;
      }
      ++nbr;
    }
    tfel::raise(
        "CMaterialPropertyInterfaceBase::getVariableNumber: "
        "no inputs named '" +
        n + "'");
  }  // end of getVariableNumber

  static void writePhysicalBounds(std::ostream& out,
                                  const MaterialPropertyDescription& mpd) {
    for (const auto& i : mpd.inputs) {
      if (!i.hasPhysicalBounds()) {
        continue;
      }
      const auto& b = i.getPhysicalBounds();
      const auto nbr =
          CMaterialPropertyInterfaceBase::getVariableNumber(mpd, i.name);
      const auto cast_start = useQuantities(mpd) ? i.type + "(" : "";
      const auto cast_end = useQuantities(mpd) ? ")" : "";
      if (b.boundsType == VariableBoundsDescription::LOWER) {
        out << "if(" << i.name << " < " << cast_start << b.lowerBound
            << cast_end << "){\n"
            << "return -" << nbr << ";\n"
            << "}\n";
      } else if (b.boundsType == VariableBoundsDescription::UPPER) {
        out << "if(" << i.name << " > " << cast_start << b.upperBound
            << cast_end << "){\n"
            << "return -" << nbr << ";\n"
            << "}\n";
      } else {
        out << "if((" << i.name << " < " << cast_start << b.lowerBound
            << cast_end << ")||"
            << "(" << i.name << " > " << cast_start << b.upperBound << cast_end
            << ")){\n"
            << "return -" << nbr << ";\n"
            << "}\n";
      }
    }
  }

  static void writeBounds(std::ostream& out,
                          const MaterialPropertyDescription& mpd) {
    for (const auto& i : mpd.inputs) {
      if (!i.hasBounds()) {
        continue;
      }
      const auto& b = i.getBounds();
      const auto nbr =
          CMaterialPropertyInterfaceBase::getVariableNumber(mpd, i.name);
      const auto cast_start = useQuantities(mpd) ? i.type + "(" : "";
      const auto cast_end = useQuantities(mpd) ? ")" : "";
      if (b.boundsType == VariableBoundsDescription::LOWER) {
        out << "if(" << i.name << " < " << cast_start << b.lowerBound
            << cast_end << "){\n"
            << "return " << nbr << ";\n"
            << "}\n";
      } else if (b.boundsType == VariableBoundsDescription::UPPER) {
        out << "if(" << i.name << " > " << cast_start << b.upperBound
            << cast_end << "){\n"
            << "return " << nbr << ";\n"
            << "}\n";
      } else {
        out << "if((" << i.name << " < " << cast_start << b.lowerBound
            << cast_end << ")||"
            << "(" << i.name << " > " << cast_start << b.upperBound << cast_end
            << ")){\n"
            << "return " << nbr << ";\n"
            << "}\n";
      }
    }
  }

  void CMaterialPropertyInterfaceBase::writeEntryPointSymbol(
      std::ostream& os, const MaterialPropertyDescription& mpd) const {
    mfront::writeEntryPointSymbol(os, this->getFunctionName(mpd));
  }  // end of writeEntryPointSymbol

  void CMaterialPropertyInterfaceBase::writeTFELVersionSymbol(
      std::ostream& os, const MaterialPropertyDescription& mpd) const {
    mfront::writeTFELVersionSymbol(os, this->getFunctionName(mpd));
  }  // end of writeTFELVersionSymbol

  void CMaterialPropertyInterfaceBase::writeMaterialSymbol(
      std::ostream& os, const MaterialPropertyDescription& mpd) const {
    mfront::writeMaterialSymbol(os, this->getFunctionName(mpd), mpd.material);
  }  // end of writeMaterialSymbol

  void CMaterialPropertyInterfaceBase::writeMaterialKnowledgeTypeSymbol(
      std::ostream& os, const MaterialPropertyDescription& mpd) const {
    mfront::writeMaterialKnowledgeTypeSymbol(os, this->getFunctionName(mpd),
                                             MATERIALPROPERTY);
  }  // end of writeMaterialKnowledgeTypeSymbol

  void CMaterialPropertyInterfaceBase::writeVariablesNamesSymbol(
      std::ostream& os,
      const std::string& name,
      const MaterialPropertyDescription& mpd) const {
    mfront::writeVariablesNamesSymbol(os, name, mpd);
  }  // end of writeVariablesNamesSymbol

  void CMaterialPropertyInterfaceBase::writeVariablesBoundsSymbols(
      std::ostream& os,
      const std::string& name,
      const MaterialPropertyDescription& mpd) const {
    mfront::writeVariablesBoundsSymbols(os, name, mpd);
  }  // end of writeVariablesBoundsSymbols

  void CMaterialPropertyInterfaceBase::writeSrcFile(
      const MaterialPropertyDescription& mpd, const FileDescription& fd) const {
    // opening the source file
    const auto src = this->getSrcFileName(mpd.material, mpd.className);
    const auto fn = "src/" + src + ".cxx";
    const auto name =
        (!mpd.material.empty()) ? mpd.material + "_" + mpd.law : mpd.law;
    std::ofstream os(fn);
    tfel::raise_if(!os,
                   "CMaterialPropertyInterfaceBase::writeOutputFiles : "
                   "unable to open '" +
                       fn + "' for writing output file.");
    os.exceptions(std::ios::badbit | std::ios::failbit);
    os << "/*!\n"
       << " * \\file   " << fn << '\n'
       << " * \\brief  "
       << "this file implements the " << mpd.className << " MaterialLaw.\n"
       << " *         File generated by " << MFrontHeader::getVersionName()
       << " "
       << "version " << MFrontHeader::getVersionNumber() << '\n';
    if (!fd.authorName.empty()) {
      os << "* \\fd.author " << fd.authorName << '\n';
    }
    if (!fd.date.empty()) {
      os << "* \\date   " << fd.date << '\n';
    }
    os << " */\n\n"
       << "#include<cmath>\n"
       << "#include<cerrno>\n"
       << "#include<algorithm>\n"
       << "#include\"TFEL/Config/TFELTypes.hxx\"\n"
       << "#include\"TFEL/Math/General/IEEE754.hxx\"\n\n";
    if (useQuantities(mpd)) {
      os << "#include\"TFEL/Math/qt.hxx\"\n\n"
         << "#include\"TFEL/Math/Quantity/qtIO.hxx\"\n\n";
    }
    if (!mpd.includes.empty()) {
      os << mpd.includes << "\n\n";
    }
    const auto header = this->getHeaderFileName(mpd.material, mpd.className);
    if (!header.empty()) {
      os << "#include\"" + header + ".hxx\"\n\n";
    }
    this->writeSrcPreprocessorDirectives(os, mpd);
    this->writeVariablesNamesSymbol(os, name, mpd);
    this->writeVariablesBoundsSymbols(os, name, mpd);
    this->writeEntryPointSymbol(os, mpd);
    this->writeTFELVersionSymbol(os, mpd);
    this->writeInterfaceSymbol(os, mpd);
    this->writeMaterialSymbol(os, mpd);
    this->writeMaterialKnowledgeTypeSymbol(os, mpd);
    this->writeBeginSrcNamespace(os);
    os << "double " << this->getFunctionName(mpd) << "(";
    this->writeArgumentsList(os, mpd);
    os << ")\n{\n";
    writeBeginningOfMaterialPropertyBody(os, mpd, fd, "double", true);
    // parameters
    if (!mpd.parameters.empty()) {
      for (const auto& p : mpd.parameters) {
        tfel::raise_if(!p.hasAttribute(VariableDescription::defaultValue),
                       "CMaterialPropertyInterfaceBase::writeSrcFile : "
                       "internal error (can't find value of "
                       "parameter '" +
                           p.name + "')");
        os << "static constexpr auto " << p.name << " = " << p.type << "("
           << p.getAttribute<double>(VariableDescription::defaultValue)
           << ");\n";
      }
    }
    this->writeInterfaceSpecificVariables(os, mpd);
    if (!mpd.inputs.empty()) {
      os << "#ifndef MFRONT_NOERRNO_HANDLING\n"
         << "const auto mfront_errno_old = errno;\n"
         << "errno=0;\n"
         << "#endif /* MFRONT_NOERRNO_HANDLING */\n";
    }
    os << mpd.output.type << " " << mpd.output.name << ";\n"
       << mpd.f.body << "\n";
    if (!mpd.inputs.empty()) {
      os << "#ifndef MFRONT_NOERRNO_HANDLING\n"
         // can't use std::swap here as errno might be a macro
         << "const auto mfront_errno = errno;\n"
         << "errno = mfront_errno_old;\n"
         << "if((mfront_errno != 0)||"
         << "(!tfel::math::ieee754::isfinite(" << mpd.output.name << "))){\n";
      this->writeCErrorTreatment(os, mpd);
      os << "}\n"
         << "#endif /* MFRONT_NOERRNO_HANDLING */\n";
    }
    if (useQuantities(mpd)) {
      os << "return " << mpd.output.name << ".getValue();\n";
    } else {
      os << "return " << mpd.output.name << ";\n";
    }
    os << "} /* end of " << mpd.className << " */\n\n";
    if (((hasBounds(mpd.inputs)) || (hasPhysicalBounds(mpd.inputs))) ||
        (this->requiresCheckBoundsFunction())) {
      os << "int " << this->getCheckBoundsFunctionName(mpd);
      os << "(";
      this->writeArgumentsList(os, mpd);
      os << ")\n{\n";
      writeScalarStandardTypedefs(os, mpd, "double", true);
      this->writeInterfaceSpecificVariables(os, mpd);
      for (const auto& i : mpd.inputs) {
        os << "static_cast<void>(" << i.name << ");\n";
      }
      if (hasPhysicalBounds(mpd.inputs)) {
        os << "/* treating mpd.physical bounds */\n";
        writePhysicalBounds(os, mpd);
      }
      if (hasBounds(mpd.inputs)) {
        os << "/* treating standard bounds */\n";
        writeBounds(os, mpd);
      }
      os << "return 0;\n} /* end of " << mpd.className << "_checkBounds */\n\n";
    }
    this->writeEndSrcNamespace(os);
    os.close();
  }  // end of writeSrcFile

  void CMaterialPropertyInterfaceBase::writeCErrorTreatment(
      std::ostream& os, const MaterialPropertyDescription& mpd) const {
    os << "return std::nan(\"" << this->getFunctionName(mpd)
       << ": invalid call to a C function (errno is not null)\");\n";
  }  // end of writeCErrorTreatment

  CMaterialPropertyInterfaceBase::~CMaterialPropertyInterfaceBase() = default;

}  // end of namespace mfront
