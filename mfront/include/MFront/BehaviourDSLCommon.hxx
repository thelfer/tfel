/*!
 * \file   mfront/include/MFront/BehaviourDSLCommon.hxx
 * \brief
 *
 * \author Helfer Thomas
 * \date   05 mai 2008
 * \copyright Copyright (C) 2006-2025 CEA/DEN, EDF R&D. All rights
 * reserved.
 * This project is publicly released under either the GNU GPL Licence with
 * linking exception or the CECILL-A licence. A copy of thoses licences are
 * delivered with the sources of TFEL. CEA or EDF may also distribute this
 * project under specific licensing conditions.
 */

#ifndef LIB_MFRONT_MFRONTBEHAVIOURDSLCOMMON_HXX
#define LIB_MFRONT_MFRONTBEHAVIOURDSLCOMMON_HXX

#include <set>
#include <map>
#include <vector>
#include <string>
#include <memory>
#include <fstream>
#include <functional>

#include "MFront/MFrontConfig.hxx"
#include "MFront/DSLBase.hxx"
#include "MFront/SupportedTypes.hxx"
#include "MFront/AbstractBehaviourDSL.hxx"
#include "MFront/BehaviourDescription.hxx"

namespace mfront {

  // forward declaration
  struct AbstractBehaviourInterface;
  // forward declaration
  struct AbstractBehaviourBrick;

  /*!
   * This class provides most functionnalities used by mechanical
   * behaviour parsers.
   *
   */
  struct MFRONT_VISIBILITY_EXPORT BehaviourDSLCommon
      : public virtual AbstractBehaviourDSL,
        public DSLBase,
        public SupportedTypes {
    //! a simple alias
    using OrthotropicAxesConvention = tfel::material::OrthotropicAxesConvention;
    //! \return the behaviour description
    virtual const BehaviourDescription& getBehaviourDescription(
        void) const override final;
    /*!
     * \brief This function handles a material property treated as a
     * dependency of the current file.
     *
     * This function:
     * - analyse the given file using the MaterialPropertyDSL
     * - register the function name generated by the MFront interface
     * - add the function name to the list of material laws used by
     *   the current file
     * - declared the headers generated by the MFront interface for inclusion
     * - launch mfront in a sub-process to generate the source files
     *   associated with this material property and have them compiled
     *   when mandatory (done by the callMFront method).
     *
     * \param[in] f : file in which the material law is
     * implemented. This must be the full path.
     */
    virtual std::shared_ptr<MaterialPropertyDescription>
    handleMaterialPropertyDescription(const std::string&) override;
    /*!
     * \brief import a file
     * \param[in] f     : file name
     * \param[in] ecmds : additionnal commands inserted treated before
     * the input file commands (those commands are given through the
     * `--@??` option of the command line
     * \param[in] s : substitutions patterns inserted (those
     * substitutions are given through command-line options such as
     * `--@YYY@=XXX`)
     *
     */
    virtual void analyseFile(
        const std::string&,
        const std::vector<std::string>&,
        const std::map<std::string, std::string>&) override;

   protected:
    /*!
     * create a variable modifier from a method
     */
    template <typename T, typename T2>
    struct TFEL_VISIBILITY_LOCAL StandardVariableModifier final
        : public VariableModifier {
      //! a simple alias
      typedef std::string (T2::*MPtr)(const Hypothesis,
                                      const std::string&,
                                      const bool);
      /*!
       * constructor
       */
      StandardVariableModifier(T&, const Hypothesis, const MPtr);
      /*!
       * \param[in] v : the variable name
       * \param[in] b : true if "this" shall be added
       */
      virtual std::string exe(const std::string&, const bool) override;
      /*!
       * destructor
       */
      virtual ~StandardVariableModifier();

     private:
      T& instance;
      const Hypothesis hypothesis;
      const MPtr mptr;
    };
    /*!
     * create a standard variable modifier from an instance of a class
     * and a pointer to a member
     */
    template <typename T, typename T2>
    std::shared_ptr<VariableModifier> makeVariableModifier(
        T&,
        const Hypothesis,
        std::string (T2::*)(const Hypothesis, const std::string&, const bool));
    template <typename T, typename T2>
    struct TFEL_VISIBILITY_LOCAL StandardWordAnalyser final
        : public WordAnalyser {
      //! a simple alias
      typedef void (T2::*MPtr)(const Hypothesis, const std::string&);
      /*!
       * constructor
       */
      StandardWordAnalyser(T&, const Hypothesis, const MPtr);
      /*!
       * \param[in] k : the current word
       */
      virtual void exe(const std::string&) override;
      /*!
       * destructor
       */
      virtual ~StandardWordAnalyser();

     private:
      T& instance;
      const MPtr mptr;
      const Hypothesis hypothesis;
    };
    /*!
     * create a standard variable modifier from an instance of a class
     * and a pointer to a member
     */
    template <typename T, typename T2>
    std::shared_ptr<WordAnalyser> makeWordAnalyser(
        T&,
        const Hypothesis,
        void (T2::*)(const Hypothesis, const std::string&));
    /*!
     * option to code blocks
     */
    struct CodeBlockOptions {
      //! a simple alias
      typedef BehaviourData::Mode Mode;
      //! a simple alias
      typedef BehaviourData::Position Position;
      //! constructor
      CodeBlockOptions();
      CodeBlockOptions(CodeBlockOptions&&) = default;
      CodeBlockOptions(const CodeBlockOptions&) = default;
      CodeBlockOptions& operator=(CodeBlockOptions&&) = default;
      CodeBlockOptions& operator=(const CodeBlockOptions&) = default;
      ~CodeBlockOptions();
      //! position where the code block will be inserted (body by defaut)
      Position p;
      //! insertion mode (create or append by default)
      Mode m;
      //! list of hypothesis
      std::set<Hypothesis> hypotheses;
      //! list of untreated options
      std::vector<tfel::utilities::Token> untreated;
    };
    /*!
     * \return the name of the generated class
     */
    virtual std::string getClassName(void) const override;
    /*!
     * \brief add a material law
     * \param[in] m : added material law name
     */
    virtual void addMaterialLaw(const std::string&) override;
    /*!
     * \brief append the given code to the includes
     */
    virtual void appendToIncludes(const std::string&) override;
    /*!
     * \brief append the given code to the members
     */
    virtual void appendToMembers(const std::string&) override;
    /*!
     * \brief append the given code to the private code
     */
    virtual void appendToPrivateCode(const std::string&) override;
    /*!
     * \brief append the given code to the sources
     */
    virtual void appendToSources(const std::string&) override;
    /*!
     * \param[out] o : options to be read
     * \param[in]  s : allow specialisation
     */
    void readCodeBlockOptions(CodeBlockOptions&, const bool);
    /*!
     * \brief read the next code block and adds it tho the mechanical
     * behaviour
     * \param[in] child : a pointer to this
     * \param[in] n     : name of the method read
     * \param[in] m     : modifier
     * \param[in] b     : add "this->" in front of variables
     * \param[in] s     : allow specialisation
     */
    template <typename T, typename T2>
    CodeBlockOptions readCodeBlock(T&,
                                   const std::string&,
                                   std::string (T2::*)(const Hypothesis,
                                                       const std::string&,
                                                       const bool),
                                   const bool,
                                   const bool);
    /*!
     * \brief read the next code block and adds it tho the mechanical
     * behaviour
     * \param[in] child : a pointer to this
     * \param[in] n     : name of the method read
     * \param[in] m     : modifier
     * \param[in] b     : add "this->" in front of variables
     */
    template <typename T, typename T2>
    void readCodeBlock(T&,
                       const CodeBlockOptions&,
                       const std::string&,
                       std::string (T2::*)(const Hypothesis,
                                           const std::string&,
                                           const bool),
                       const bool);
    /*!
     * \brief read the next code block and adds it tho the mechanical
     * behaviour
     * \param[in] child : a pointer to this
     * \param[in] n     : name of the method read
     * \param[in] m     : modifier
     * \param[in] a     : word analyser
     * \param[in] b     : add "this->" in front of variables
     * \param[in] s     : allow specialisation
     */
    template <typename T, typename T2, typename T3>
    CodeBlockOptions readCodeBlock(
        T&,
        const std::string&,
        std::string (T2::*)(const Hypothesis, const std::string&, const bool),
        void (T3::*)(const Hypothesis, const std::string&),
        const bool,
        const bool);
    /*!
     * \brief read the next code block and adds it tho the mechanical
     * behaviour
     * \param[in] child : a pointer to this
     * \param[in] n     : name of the method read
     * \param[in] m     : modifier
     * \param[in] a     : word analyser
     * \param[in] b     : add "this->" in front of variables
     * \param[in] s     : allow specialisation
     */
    template <typename T, typename T2, typename T3>
    void readCodeBlock(T&,
                       const CodeBlockOptions&,
                       const std::string&,
                       std::string (T2::*)(const Hypothesis,
                                           const std::string&,
                                           const bool),
                       void (T3::*)(const Hypothesis, const std::string&),
                       const bool);
    /*!
     * \brief read the next code block and adds it tho the mechanical
     * behaviour
     * \param[in] child : a pointer to this
     * \param[in] n1    : name of the first method read
     * \param[in] n2    : name of the second method read
     * \param[in] m1    : modifier
     * \param[in] m2    : modifier
     * \param[in] b     : add "this->" in front of variables
     * \param[in] s     : allow specialisation
     */
    template <typename T, typename T2>
    CodeBlockOptions readCodeBlock(
        T&,
        const std::string&,
        const std::string&,
        std::string (T2::*)(const Hypothesis, const std::string&, const bool),
        std::string (T2::*)(const Hypothesis, const std::string&, const bool),
        const bool,
        const bool);
    /*!
     * \brief read the next code block and adds it tho the mechanical
     * behaviour
     * \param[in] child : a pointer to this
     * \param[in] n1    : name of the first method read
     * \param[in] n2    : name of the second method read
     * \param[in] m1    : modifier
     * \param[in] m2    : modifier
     * \param[in] b     : add "this->" in front of variables
     */
    template <typename T, typename T2>
    void readCodeBlock(
        T&,
        const CodeBlockOptions&,
        const std::string&,
        const std::string&,
        std::string (T2::*)(const Hypothesis, const std::string&, const bool),
        std::string (T2::*)(const Hypothesis, const std::string&, const bool),
        const bool);
    /*!
     * \brief throw an exception is some options were not recognized
     */
    void treatUnsupportedCodeBlockOptions(const CodeBlockOptions&);
    /*!
     * \brief add a static variable description
     * \param[in] v : variable description
     */
    virtual void addStaticVariableDescription(
        const StaticVariableDescription&) override;
    /*!
     * disable the declaration of new variables
     * \param[in] h : modelling hypothesis
     */
    virtual void disableVariableDeclaration(const Hypothesis);
    /*!
     * write the output files
     */
    virtual void generateOutputFiles(void) override;
    /*!
     * \return the list of hypothesis a priori supported by
     * the parser.
     *
     * To enable other hypothesis or restrict the hypotheses
     * supported, the user must use the `@ModellingHypothesis` or
     * `@ModellingHypotheses` keywords.
     */
    virtual std::set<Hypothesis> getDefaultModellingHypotheses(
        void) const override;
    /*!
     * \return true if the given modelling hypothesis is handled by
     * the parser
     *
     * Some parsers have restrictions on the modelling hypotheses
     * supported. For example, the isotropic behaviours were not able
     * to handle plane stress hypotheses when this comment was
     * written(but it was planned, so this comment may be outdated
     * now).
     *
     * The fact that this method returns true means that the user
     * *can* provide code to support this modelling hypothesis. For
     * example, to support plane stress in RungeKutta and Implicit
     * parsers, the user must provide some hand-crafted code. He must
     * enable this modelling hypothesis by calling explicitely
     * `@ModellingHypothesis` or `@ModellingHypotheses` keywords.
     */
    virtual bool isModellingHypothesisSupported(
        const Hypothesis) const override;
    /*!
     *
     */
    virtual void endsInputFileProcessing();
    /*!
     * \brief the standard variable modifier
     * \param[in] h : modelling hypothesis
     * \param[in] v : variable name
     * \param[in] b : if true, shall add the "this" qualifier
     */
    virtual std::string standardModifier(const Hypothesis,
                                         const std::string&,
                                         const bool);

    virtual std::string predictionOperatorVariableModifier(const Hypothesis,
                                                           const std::string&,
                                                           const bool);

    virtual std::string tangentOperatorVariableModifier(const Hypothesis,
                                                        const std::string&,
                                                        const bool);
    /*!
     * \brief extract a material property from a token. If the token
     * is a string, it is interpred as a mfront file name. Otherwise,
     * the token is converted to a scalar.
     * \param[in] m: calling method
     * \param[in] t: token
     * \return a material property
     */
    BehaviourDescription::MaterialProperty extractMaterialProperty(
        const std::string&, const tfel::utilities::Token&);
    /*!
     * \brief read an an array of material properties. String are
     * interpreted as mfront file name. Other tokens are interpreted
     * as long double.
     * \param[in] m: calling method
     * \return the array of material properties
     */
    virtual std::vector<BehaviourDescription::MaterialProperty>
    readMaterialPropertyOrArrayOfMaterialProperties(const std::string& m);
    /*!
     *
     */
    virtual void readStringList(std::vector<std::string>&);
    /*!
     * read a list of hypotheses
     * \param[out] h : list of hypotheses
     * \note by default, the returning set contains UNDEFINEDHYPOTHESIS
     */
    virtual void readHypothesesList(std::set<Hypothesis>&);
    /*!
     * \brief append the given modelling hypothesis to the set of hypothesis
     * \param[out] h : list of hypotheses
     * \param[in]  v : hypothesis to be inserted
     */
    void appendToHypothesesList(std::set<Hypothesis>&,
                                const std::string&) const;
    /*!
     * First read a set of Hypothesis. Then read a list variables and
     * assign them to mechanical data associated with those hypotheses.
     * \param[out] v  : the declared variables
     * \param[out] h  : modelling hypothesis on which the variables were
     * declared \param[in]  m  : method used to assign the variables \param[in]
     * b1 : allows variables to be declared as array \param[in]  b2 : if true,
     * allows variable declaration after that a code block has been defined
     * (this is a priori only valid for local variables)
     */
    virtual void readVariableList(
        VariableDescriptionContainer&,
        std::set<Hypothesis>&,
        void (BehaviourDescription::*)(const Hypothesis,
                                       const VariableDescriptionContainer&,
                                       const BehaviourData::RegistrationStatus),
        const bool,
        const bool);

    /*!
     * Assign a list variables to mechanical data associated with the given
     * hypotheses. \param[out] h : modelling hypothesis on which the variables
     * were declared \param[out] v : the declared variables \param[in]  m :
     * method used to assign the variables \param[in]  b : if true, allows
     * variable declaration after that a code block has been defined (this is a
     *                  priori only valid for local variables)
     */
    virtual void addVariableList(
        const std::set<Hypothesis>&,
        const VariableDescriptionContainer&,
        void (BehaviourDescription::*)(const Hypothesis,
                                       const VariableDescriptionContainer&,
                                       const BehaviourData::RegistrationStatus),
        const bool);

    /*!
     * set the interfaces to be used
     */
    virtual void setInterfaces(const std::set<std::string>&) override;
    /*!
     * \brief register a name.
     * \param[in] n : name
     */
    virtual void reserveName(const std::string&) override;
    /*!
     * \brief look if a name is reserved
     * \param[in] n : name
     */
    virtual bool isNameReserved(const std::string&) const override;
    /*!
     * register the default variable names
     */
    virtual void registerDefaultVarNames(void);
    //!\brief treat the @Brick keyword
    virtual void treatBrick(void);
    //!\brief treat the @Model keyword
    virtual void treatModel();
    /*!
     * \brief get a model description from an mfront file
     * \param[in] m: file
     * \return a model description
     */
    virtual ModelDescription getModelDescription(const std::string&);
    //! \brief treat the @Private keyword
    virtual void treatPrivate(void) override;
    //! \brief treat the @Members keyword
    virtual void treatMembers(void) override;
    //! \brief treat the @TangentOperator keyword
    virtual void treatTangentOperator(void);
    //! \brief treat the @IsTangentOperatorSymmetric keyword
    virtual void treatIsTangentOperatorSymmetric(void);
    //! \brief treat the @Material keyword
    virtual void treatMaterial(void);
    //! \brief treat the @Library keyword
    virtual void treatLibrary(void);
    //! \brief treat the @Profiling keyword
    virtual void treatProfiling(void);
    //! \brief treat the @ModellingHypothesis keyword
    virtual void treatModellingHypothesis(void);
    //! \brief treat the @ModellingHypotheses keyword
    virtual void treatModellingHypotheses(void);
    //! \brief treat the @UpdateAuxiliaryStateVariables keyword
    virtual void treatUpdateAuxiliaryStateVariables(void);
    //! \brief treat the @InternalEnergy keyword
    virtual void treatInternalEnergy(void);
    //! \brief treat the @DissipatedEnergy keyword
    virtual void treatDissipatedEnergy(void);
    //! \brief treat the @ComputeStressFreeExpansion keyword
    virtual void treatComputeStressFreeExpansion(void);
    //! \brief treat the @UsableInPurelyImplicitResolution keyword
    virtual void treatUsableInPurelyImplicitResolution(void);
    //! \brief treat the @Parameter keyword
    virtual void treatParameter(void);
    //! \brief treat the @LocalVariables keyword
    virtual void treatLocalVar(void);
    //! handle the @ComputeThermalExpansion keyword
    virtual void treatComputeThermalExpansion(void);
    //! handle the @ComputeStiffnessTensor keyword
    virtual void treatComputeStiffnessTensor(void);
    //! handle the @ElasticMaterialProperties keyword
    virtual void treatElasticMaterialProperties(void);
    /*!
     * \brief read the elastic material properties and assign them to
     * the behaviour Description
     */
    virtual void readElasticMaterialProperties(void);
    //! \brief handle the @HillTensor keyword
    virtual void treatHillTensor(void);
    //! \brief handle the @InitLocalVariables keyword
    virtual void treatInitLocalVariables(void);
    //! \brief handle the @OrthotropicBehaviour keyword
    virtual void treatOrthotropicBehaviour(void);
    //! \brief handle the @IsotropicElasticBehaiour keyword
    virtual void treatIsotropicElasticBehaviour(void);
    //! \brief handle the @IsotropicBehaviour keyword
    virtual void treatIsotropicBehaviour(void);
    //! \brief handle the @RequireStiffnessOperator keyword
    virtual void treatRequireStiffnessOperator(void);
    //! \brief handle the @RequireStiffnessTensor keyword
    virtual void treatRequireStiffnessTensor(void);

    virtual void treatStiffnessTensorOption(void);
    //! \brief handle the @RequireThermalExpansionCoefficientTensor keyword
    virtual void treatRequireThermalExpansionCoefficientTensor(void);
    //! \brief handle the @Behaviour keyword
    virtual void treatBehaviour(void);
    //! \brief handle the @Interface keyword
    virtual void treatInterface(void);
    //! \brief handle the @StateVariable keyword
    virtual void treatStateVariable(void);
    //! \brief handle the @AuxiliaryStateVariable keyword
    virtual void treatAuxiliaryStateVariable(void);
    //! \brief handle the @ExternalStateVariable keyword
    virtual void treatExternalStateVariable(void);
    //! \brief treat the @MinimalTimeStepScalingFactor keyword
    virtual void treatMinimalTimeStepScalingFactor(void);
    //! \brief treat the @MaximalTimeStepScalingFactor keyword
    virtual void treatMaximalTimeStepScalingFactor(void);
    //! \brief treat the @APrioriTimeStepScalingFactor keyword
    virtual void treatAPrioriTimeStepScalingFactor(void);
    //! \brief treat the @Integrator keyword
    virtual void treatIntegrator(void);
    //! \brief treat the @APosterioriTimeStepScalingFactor keyword
    virtual void treatAPosterioriTimeStepScalingFactor(void);
    //! \brief treat the @MaterialProperty and the @Coef keywords
    virtual void treatCoef(void);
    //! \brief treat the @UseQt keyword
    virtual void treatUseQt(void);
    //! \brief treat the @Bounds keyword
    virtual void treatBounds(void);
    //! \brief treat the @PhysicalBounds keyword
    virtual void treatPhysicalBounds(void);
    /*!
     * \param[out] d : bounds description
     * \param[in]  h : modelling hypothesis
     */
    virtual void treatBounds(BoundsDescription&, const Hypothesis);
    //! \brief treat the @PredictionOperator keyword
    virtual void treatPredictionOperator(void);
    //! \brief treat the @Swelling keyword
    virtual void treatSwelling(void);
    //! \brief treat the @AxialGrowth keyword
    virtual void treatAxialGrowth(void);
    //! \brief treat the @Relocation keyword
    virtual void treatRelocation();
    /*!
     * \brief read a swelling description.
     *
     * An array is expected at the current point of the file. Each
     * token of the array is analysed throw the
     * readStressFreeExpansionHandler method.
     */
    virtual std::vector<BehaviourData::StressFreeExpansionHandler>
    readStressFreeExpansionHandler(void);
    /*!
     * \brief extract a swelling description from a token
     * \param[in] t: treated token
     *
     * - if the token is a string, a mfront file is treated.
     * - if the token is not a string, one expects an external state
     *   variable name
     */
    virtual BehaviourData::StressFreeExpansionHandler
    readStressFreeExpansionHandler(const tfel::utilities::Token&);

    virtual void writeIncludes(std::ostream&);

    virtual void writeNamespaceBegin(std::ostream&);

    virtual void writeNamespaceEnd(std::ostream&);

    virtual void writeStandardTFELTypedefs(std::ostream&);

    virtual void checkBehaviourDataFile(void) const;

    virtual void writeBehaviourDataStandardTFELTypedefs(void);

    virtual void writeBehaviourDataStandardTFELIncludes(void);

    virtual void writeBehaviourDataFileHeader(void);

    virtual void writeBehaviourDataFileHeaderBegin(void);

    virtual void writeBehaviourDataFileHeaderEnd(void);

    virtual void writeBehaviourDataClassHeader(void);

    virtual void writeBehaviourDataDisabledConstructors(void);

    virtual void writeBehaviourDataConstructors(const Hypothesis);
    /*!
     * write interface's setters for the main variables
     */
    virtual void writeBehaviourDataMainVariablesSetters(void);

    virtual void writeBehaviourDataClassBegin(const Hypothesis);

    virtual void writeBehaviourDataClassEnd(void);

    virtual void writeBehaviourDataDefaultMembers(void);

    virtual void writeBehaviourDataMaterialProperties(const Hypothesis);

    virtual void writeBehaviourDataStateVariables(const Hypothesis);

    virtual void writeBehaviourDataAssignementOperator(const Hypothesis);

    virtual void writeBehaviourDataOutputOperator(const Hypothesis);

    virtual void writeBehaviourDataExport(const Hypothesis);

    virtual void writeBehaviourDataPublicMembers(void);

    virtual void writeBehaviourDataFileBegin(void);

    virtual void writeBehaviourDataFileEnd(void);

    virtual void writeBehaviourDataClass(const Hypothesis);

    virtual void writeBehaviourDataForwardDeclarations(void);

    virtual void checkIntegrationDataFile(void) const;

    virtual void writeIntegrationDataStandardTFELTypedefs(void);

    virtual void writeIntegrationDataStandardTFELIncludes(void);

    virtual void writeIntegrationDataFileHeader(void);

    virtual void writeIntegrationDataFileHeaderBegin(void);

    virtual void writeIntegrationDataFileHeaderEnd(void);

    virtual void writeIntegrationDataClassHeader(void);

    virtual void writeIntegrationDataDisabledConstructors(void);

    virtual void writeIntegrationDataConstructors(const Hypothesis);
    /*!
     * write interface's setters for the main variables
     */
    virtual void writeIntegrationDataMainVariablesSetters(void);

    virtual void writeIntegrationDataScaleOperators(const Hypothesis);

    virtual void writeIntegrationDataUpdateDrivingVariablesMethod();

    virtual void writeIntegrationDataClassBegin(const Hypothesis);

    virtual void writeIntegrationDataClassEnd(void);

    virtual void writeIntegrationDataDefaultMembers(void);

    virtual void writeIntegrationDataExternalStateVariables(const Hypothesis);

    virtual void writeIntegrationDataFileBegin(void);

    virtual void writeIntegrationDataFileEnd(void);

    virtual void writeIntegrationDataClass(const Hypothesis);

    virtual void writeIntegrationDataForwardDeclarations(void);

    virtual void writeIntegrationDataOutputOperator(const Hypothesis);

    virtual void checkBehaviourFile(void) const;

    virtual void writeBehaviourStandardTFELTypedefs(void);

    virtual void writeBehaviourFileHeader(void);

    virtual void writeBehaviourFileHeaderBegin(void);

    virtual void writeBehaviourFileHeaderEnd(void);

    virtual void writeBehaviourFileBegin(void);

    virtual void writeBehaviourFileEnd(void);

    virtual void writeBehaviourClass(const Hypothesis);

    virtual void writeBehaviourForwardDeclarations(void);

    virtual void writeBehaviourProfiler(void);

    virtual void writeBehaviourParserSpecificInheritanceRelationship(void);

    virtual void writeBehaviourParserSpecificTypedefs(void);

    virtual void writeBehaviourParserSpecificMembers(const Hypothesis);

    virtual void writeBehaviourParserSpecificIncludes(void);

    virtual void writeBehaviourClassBegin(const Hypothesis);

    virtual void writeBehaviourGetModellingHypothesis(void);

    virtual void writeBehaviourClassEnd(void);

    virtual void writeBehaviourPolicyVariable(void);

    virtual void writeBehaviourSetOutOfBoundsPolicy(void);

    virtual void writeBehaviourCheckBounds(const Hypothesis);

    virtual void writeBehaviourDisabledConstructors(void);

    virtual void writeBehaviourConstructors(const Hypothesis);

    /*!
     * \return behaviour constructor initializers.
     */
    virtual std::string getBehaviourConstructorsInitializers(const Hypothesis);
    /*!
     * \brief write the arguments of a material property, including
     * the the surrounding parenthesis. Those arguments are used to
     * evaluate the material property and/or check its bounds.
     * \param[out] out: output stream
     * \param[in]  m:   material property description
     * \param[in]  f:   function converting input variable name.
     * The function f can be used to specify how evaluate a variable value.
     * For example, if we want to evaluate the variable name 'V' at
     * the end of the time step, we could make f return V+dV
     */
    virtual void writeMaterialPropertyArguments(
        std::ostream&,
        const BehaviourDescription::ComputedMaterialProperty&,
        std::function<std::string(const MaterialPropertyInput&)>&);
    /*!
     * \brief write the bounds checks to a material property
     * \param[out] out: output stream
     * \param[in]  m:   material property description
     * \param[in]  f:   function converting input variable name.
     * The function f can be used to specify how evaluate a variable value.
     * For example, if we want to evaluate the variable name 'V' at
     * the end of the time step, we could make f return V+dV
     */
    virtual void writeMaterialPropertyCheckBoundsEvaluation(
        std::ostream&,
        const BehaviourDescription::MaterialProperty&,
        std::function<std::string(const MaterialPropertyInput&)>&);
    /*!
     * \brief write the call to a material property
     * \param[out] out: output stream
     * \param[in]  m:   material property description
     * \param[in]  f:   function converting input variable name.
     * The function f can be used to specify how evaluate a variable value.
     * For example, if we want to evaluate the variable name 'V' at
     * the end of the time step, we could make f return V+dV
     */
    virtual void writeMaterialPropertyEvaluation(
        std::ostream&,
        const BehaviourDescription::MaterialProperty&,
        std::function<std::string(const MaterialPropertyInput&)>&);
    /*!
     * \brief write the evoluation of a thermal expansion coefficient
     * \param[out] out: output stream
     * \param[in]  mpd: material property
     * \param[in] T: temperature at which the thermal expansion
     * coefficient is computed
     * \param[in] i: indice
     * \param[in] s: suffix
     */
    virtual void writeThermalExpansionCoefficientComputation(
        std::ostream&,
        const BehaviourDescription::MaterialProperty&,
        const std::string&,
        const std::string&,
        const std::string&);
    virtual void writeThermalExpansionCoefficientsComputations(
        std::ostream&,
        const BehaviourDescription::MaterialProperty&,
        const std::string& = "");
    virtual void writeThermalExpansionComputation(
        std::ostream&,
        const BehaviourDescription::MaterialProperty&,
        const std::string&,
        const std::string&,
        const std::string& = "");
    /*!
     * \brief write the behaviour's computeStressFreeExpansion method, if
     * mandatory.
     * \param[in] h : modelling hypothesis
     */
    virtual void writeBehaviourComputeStressFreeExpansion(const Hypothesis);
    /*!
     * \brief write the stiffness tensor computation evaluation
     * from the elastic material properties.
     * \param[out] out: output stream
     * \param[in]  D:   name of the stiffness tensor variable
     * \param[in]  f:   function used to handle the variables of the material
     * properties.
     */
    virtual void writeStiffnessTensorComputation(
        std::ostream&,
        const std::string&,
        std::function<std::string(const MaterialPropertyInput&)>&);
    /*!
     * \brief write the Hill tensor computation evaluation
     * from the elastic material properties.
     * \param[out] out: output stream
     * \param[in]  H:   name of the Hill tensor variable to be computed
     * \param[in]  h:   Hill tensor definition
     * \param[in]  f:   function used to handle the variables of the material
     * properties.
     */
    virtual void writeHillTensorComputation(
        std::ostream&,
        const std::string&,
        const BehaviourDescription::HillTensor&,
        std::function<std::string(const MaterialPropertyInput&)>&);
    /*!
     * \brief write the initalize method . This method is called after that
     * the main variables were set.
     */
    virtual void writeBehaviourInitializeMethod(const Hypothesis);
    /*!
     * write part of the constructor specific to the parser
     * \param[in] h : modelling hypothesis
     */
    virtual void writeBehaviourParserSpecificInitializeMethodPart(
        const Hypothesis);

    virtual void writeBehaviourIntegrationVariablesIncrements(const Hypothesis);

    virtual void writeBehaviourLocalVariables(const Hypothesis);

    virtual void writeBehaviourIntegrationVariables(const Hypothesis);

    virtual void writeBehaviourParameters(const Hypothesis);

    virtual void writeBehaviourStaticVariables(const Hypothesis);

    virtual void writeBehaviourAdditionalMembers(const Hypothesis);

    virtual void writeBehaviourPrivate(const Hypothesis);

    virtual void writeBehaviourUpdateIntegrationVariables(const Hypothesis);

    virtual void writeBehaviourUpdateStateVariables(const Hypothesis);

    virtual void writeBehaviourUpdateAuxiliaryStateVariables(const Hypothesis);
    /*!
     * \brief write the computeInternalEnergy method
     * \param[in] h: modelling hypothesis
     */
    virtual void writeBehaviourComputeInternalEnergy(const Hypothesis);
    /*!
     * \brief write the computeInternalEnergy method
     * \param[in] h: modelling hypothesis
     */
    virtual void writeBehaviourComputeDissipatedEnergy(const Hypothesis);
    //! \brief write the getTimeStepScalingFactor method
    virtual void writeBehaviourGetTimeStepScalingFactor(void);
    //! \brief write the integrate method
    virtual void writeBehaviourIntegrator(const Hypothesis);
    /*!
     * \brief write the computeAPrioriTimeStepsScalingFactor method
     */
    virtual void writeBehaviourComputeAPrioriTimeStepScalingFactor();
    /*!
     * \brief write the computeAPrioriTimeStepsScalingFactorII method
     */
    virtual void writeBehaviourComputeAPrioriTimeStepScalingFactorII(
        const Hypothesis);
    /*!
     * \brief write the computeAPosterioriTimeStepsScalingFactor method
     */
    virtual void writeBehaviourComputeAPosterioriTimeStepScalingFactor();
    /*!
     * \brief write the computeAPosterioriTimeStepsScalingFactorII method
     */
    virtual void writeBehaviourComputeAPosterioriTimeStepScalingFactorII(
        const Hypothesis);

    virtual void writeBehaviourUpdateExternalStateVariables(const Hypothesis);

    virtual void writeBehaviourOutputOperator(const Hypothesis);

    virtual void writeBehaviourDestructor(void);

    virtual void writeBehaviourTraits(void);

    /*!
     * \param[in] h : modelling hypothesis
     * \param[in] b : true if the behaviour is defined for the given modelling
     * hypothesis
     */
    virtual void writeBehaviourTraitsSpecialisation(const Hypothesis,
                                                    const bool);

    virtual void writeBehaviourIncludes(void);

    virtual void writeBehaviourLocalVariablesInitialisation(const Hypothesis);

    virtual void writeBehaviourParameterInitialisation(const Hypothesis);

    virtual void writeBehaviourParametersInitializers();

    virtual void writeBehaviourParametersInitializer(const Hypothesis);

    virtual void checkSrcFile(void) const;

    virtual void writeSrcFileHeader(void);

    virtual void writeSrcFileUserDefinedCode(void);

    virtual void writeSrcFileBehaviourProfiler(void);

    virtual void writeSrcFileParametersInitializers(void);

    virtual void writeSrcFileParametersInitializer(const Hypothesis);

    virtual void writeSrcFileStaticVariables(const Hypothesis);
    /*!
     * \brief write the source file
     */
    virtual void writeSrcFile(void);

    virtual void writeBehaviourComputePredictionOperator(const Hypothesis);

    virtual void writeBehaviourComputeTangentOperator(const Hypothesis);

    virtual void writeBehaviourGetTangentOperator();

    virtual void writeBehaviourTangentOperator();
    /*!
     * \brief write the call to a model
     * \param[out] out: output stream
     * \param[in]  h:   hypothesis
     * \param[in]  md:  model description
     * \param[in]  vo:  name of the variable containing the result
     * \param[in]  vs:  name of the variable containing the value of the
     *                  variable modified by the model at the beginning
     *                  of the time step
     * \param[in]  bn:  base name for temporary variable
     */
    virtual void writeModelCall(std::ostream&,
                                const Hypothesis,
                                const ModelDescription&,
                                const std::string&,
                                const std::string&,
                                const std::string&);
    /*!
     * \brief treat methods associated with parameters
     * \param[in] h : modelling hypothesis
     */
    virtual void treatParameterMethod(const Hypothesis);
    /*!
     * \return true if the the given variable may have methods
     * \param[in] h : modelling hypothesis
     * \param[in] n : name
     */
    virtual bool isCallableVariable(const Hypothesis, const std::string&) const;
    /*!
     * treat a method
     * \param[in] h : modelling hypothesis
     */
    virtual void treatVariableMethod(const Hypothesis);
    /*!
     * \param[in] h : modelling hypothesis
     * \param[in] n : variable name
     */
    virtual void treatUnknownVariableMethod(const Hypothesis,
                                            const std::string&);
    //! method called when an unknown keyword is parsed
    virtual void treatUnknownKeyword(void) override;
    //! destructor
    virtual ~BehaviourDSLCommon();
    /*!
     * \param[in] h : modelling hypothesis
     * \param[in] n : variable name
     */
    virtual void
    declareExternalStateVariableProbablyUnusableInPurelyImplicitResolution(
        const Hypothesis, const std::string&);
    /*!
     * \brief if no tangent operator was provided, but that the
     * behaviour requires a stiffness matrix, this method creates a
     * minimal tangent operator for elasticity.
     * \note This method is not trivial because one has to take care
     * not to create artifical mechanical data specialisation
     * \note This method is meant to be used in the
     * endsInputFileProcessing method.
     */
    virtual void setMinimalTangentOperator(void);
    /*!
     * \brief if the compte final stress code is not available, create
     * it from the ComputeFinalStressCandidate code if it is
     * available.
     * \note This method is not trivial because one has to take care
     * not to create artifical mechanical data specialisation
     * \note This method is meant to be used in the
     * endsInputFileProcessing method.
     */
    virtual void
    setComputeFinalStressFromComputeFinalStressCandidateIfNecessary(void);
    /*!
     * \brief perform pedantic checks
     */
    virtual void doPedanticChecks(void) const;
    /*!
     * \return true if the user defined a block of code computing the
     * tangent operator
     * \param[in] h : modelling hypothesis
     */
    virtual bool hasUserDefinedTangentOperatorCode(const Hypothesis) const;
    //! constructor
    BehaviourDSLCommon();
    //! behaviour description
    BehaviourDescription mb;
    //! registred bricks
    std::vector<std::shared_ptr<AbstractBehaviourBrick>> bricks;
    //! the list of registred keywords
    std::set<std::string> registredKeyWords;
    //! list of registred interfaces, indexed by their name
    std::map<std::string, std::shared_ptr<AbstractBehaviourInterface>>
        interfaces;
    /*!
     * local variables initalizers. This variable to initialize local
     * variables defined by domains specific languages and shall not
     * be accessible to the end user.
     */
    std::string localVariablesInitializers;

    std::string behaviourFileName;
    std::string behaviourDataFileName;
    std::string integrationDataFileName;
    std::string srcFileName;

    std::ofstream behaviourFile;
    std::ofstream behaviourDataFile;
    std::ofstream integrationDataFile;
    std::ofstream srcFile;

    bool useStateVarTimeDerivative;
    bool explicitlyDeclaredUsableInPurelyImplicitResolution;
  };  // end of struct BehaviourDSLCommon

}  // end of namespace mfront

#include "MFront/BehaviourDSLCommon.ixx"

#endif /* LIB_MFRONT_MFRONTBEHAVIOURDSLCOMMON_HXX */
